// Package codegen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package codegen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	Access_tokenScopes = "access_token.Scopes"
)

// Defines values for YSKCardCardType.
const (
	YSKCardCardTypeLongNotice  YSKCardCardType = "long-notice"
	YSKCardCardTypeShortNotice YSKCardCardType = "short-notice"
	YSKCardCardTypeTask        YSKCardCardType = "task"
)

// Defines values for YSKCardRenderType.
const (
	YSKCardRenderTypeIconTextNotice YSKCardRenderType = "icon-text-notice"
	YSKCardRenderTypeListNotice     YSKCardRenderType = "list-notice"
	YSKCardRenderTypeMarkdownNotice YSKCardRenderType = "markdown-notice"
	YSKCardRenderTypeTask           YSKCardRenderType = "task"
)

// Action defines model for Action.
type Action struct {
	// Name action name
	Name string `json:"name"`

	// Properties event properties
	Properties map[string]string `json:"properties"`

	// SourceID associated source id
	SourceID string `json:"sourceID"`

	// Timestamp timestamp this action took place
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// ActionType defines model for ActionType.
type ActionType struct {
	// Name action name
	//
	// (there is no naming convention for action names, but it is recommended to name each as structural and descriptive as possible)
	Name             string         `json:"name"`
	PropertyTypeList []PropertyType `json:"propertyTypeList"`

	// SourceID action source id to identify where the action will take
	SourceID string `json:"sourceID"`
}

// BaseResponse defines model for BaseResponse.
type BaseResponse struct {
	// Message message returned by server side if there is any
	Message *string `json:"message,omitempty"`
}

// Event defines model for Event.
type Event struct {
	// Name event name
	Name string `json:"name"`

	// Properties event properties
	Properties map[string]string `json:"properties"`

	// SourceID associated source id
	SourceID string `json:"sourceID"`

	// Timestamp timestamp this event took place
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Uuid event uuid
	Uuid *string `json:"uuid,omitempty"`
}

// EventType defines model for EventType.
type EventType struct {
	// Name event name
	//
	// (there is no naming convention for event names, but it is recommended to name each as structural and descriptive as possible)
	Name             string         `json:"name"`
	PropertyTypeList []PropertyType `json:"propertyTypeList"`

	// SourceID event source id to identify where the event comes from
	SourceID string `json:"sourceID"`
}

// PropertyType defines model for PropertyType.
type PropertyType struct {
	Description *string `json:"description,omitempty"`
	Example     *string `json:"example,omitempty"`

	// Name property name
	//
	// > It is recommended for a property name to be as descriptive as possible. One option is to prefix with a namespace.
	// > - If the property is source specific, prefix with source ID. For example, `local-storage:vendor`
	// > - Otherwise, prefix with `common:`. For example, `common:email`
	// >
	// > Some bad examples are `id`, `avail`, `blk`...which can be ambiguous and confusing.
	Name string `json:"name"`
}

// YSKCard defines model for YSKCard.
type YSKCard struct {
	CardType   YSKCardCardType   `json:"cardType"`
	Content    YSKCardContent    `json:"content"`
	Id         string            `json:"id"`
	RenderType YSKCardRenderType `json:"renderType"`
}

// YSKCardCardType defines model for YSKCard.CardType.
type YSKCardCardType string

// YSKCardRenderType defines model for YSKCard.RenderType.
type YSKCardRenderType string

// YSKCardContent defines model for YSKCardContent.
type YSKCardContent struct {
	BodyIconWithText *YSKCardIconWithText   `json:"bodyIconWithText,omitempty"`
	BodyList         *[]YSKCardListItem     `json:"bodyList,omitempty"`
	BodyProgress     *YSKCardProgress       `json:"bodyProgress,omitempty"`
	FooterActions    *[]YSKCardFooterAction `json:"footerActions,omitempty"`
	TitleIcon        YSKCardIcon            `json:"titleIcon"`
	TitleText        string                 `json:"titleText"`
}

// YSKCardFooterAction defines model for YSKCardFooterAction.
type YSKCardFooterAction struct {
	MessageBus YSKCardMessageBusAction `json:"messageBus"`
	Side       string                  `json:"side"`
	Style      string                  `json:"style"`
	Text       string                  `json:"text"`
}

// YSKCardIcon defines model for YSKCardIcon.
type YSKCardIcon = string

// YSKCardIconWithText defines model for YSKCardIconWithText.
type YSKCardIconWithText struct {
	Description string      `json:"description"`
	Icon        YSKCardIcon `json:"icon"`
}

// YSKCardList defines model for YSKCardList.
type YSKCardList = []YSKCard

// YSKCardListItem defines model for YSKCardListItem.
type YSKCardListItem struct {
	Description string      `json:"description"`
	Icon        YSKCardIcon `json:"icon"`
	RightText   string      `json:"rightText"`
}

// YSKCardMessageBusAction defines model for YSKCardMessageBusAction.
type YSKCardMessageBusAction struct {
	Key     string `json:"key"`
	Payload string `json:"payload"`
}

// YSKCardProgress defines model for YSKCardProgress.
type YSKCardProgress struct {
	Label    string `json:"label"`
	Progress int    `json:"progress"`
}

// ActionName defines model for ActionName.
type ActionName = string

// ActionNames defines model for ActionNames.
type ActionNames = []string

// EventName defines model for EventName.
type EventName = string

// EventNames defines model for EventNames.
type EventNames = []string

// SourceID defines model for SourceID.
type SourceID = string

// GetActionTypeOK defines model for GetActionTypeOK.
type GetActionTypeOK = ActionType

// GetActionTypesOK defines model for GetActionTypesOK.
type GetActionTypesOK = []ActionType

// GetEventTypeOK defines model for GetEventTypeOK.
type GetEventTypeOK = EventType

// GetEventTypesOK defines model for GetEventTypesOK.
type GetEventTypesOK = []EventType

// PublishEventOK defines model for PublishEventOK.
type PublishEventOK = Event

// ResponseBadRequest defines model for ResponseBadRequest.
type ResponseBadRequest = BaseResponse

// ResponseConflict defines model for ResponseConflict.
type ResponseConflict = BaseResponse

// ResponseGetYSKCardListOK defines model for ResponseGetYSKCardListOK.
type ResponseGetYSKCardListOK struct {
	Data *YSKCardList `json:"data,omitempty"`

	// Message message returned by server side if there is any
	Message *string `json:"message,omitempty"`
}

// ResponseInternalServerError defines model for ResponseInternalServerError.
type ResponseInternalServerError = BaseResponse

// ResponseNotFound defines model for ResponseNotFound.
type ResponseNotFound = BaseResponse

// ResponseOK defines model for ResponseOK.
type ResponseOK = BaseResponse

// TriggerActionOK defines model for TriggerActionOK.
type TriggerActionOK = Action

// PublishEvent event properties
type PublishEvent map[string]string

// RegisterActionTypes defines model for RegisterActionTypes.
type RegisterActionTypes = []ActionType

// RegisterEventTypes defines model for RegisterEventTypes.
type RegisterEventTypes = []EventType

// TriggerAction action properties
type TriggerAction map[string]string

// SubscribeActionWSParams defines parameters for SubscribeActionWS.
type SubscribeActionWSParams struct {
	Names *ActionNames `form:"names,omitempty" json:"names,omitempty"`
}

// TriggerActionJSONBody defines parameters for TriggerAction.
type TriggerActionJSONBody map[string]string

// RegisterActionTypesJSONBody defines parameters for RegisterActionTypes.
type RegisterActionTypesJSONBody = []ActionType

// SubscribeEventWSParams defines parameters for SubscribeEventWS.
type SubscribeEventWSParams struct {
	Names *EventNames `form:"names,omitempty" json:"names,omitempty"`
}

// PublishEventJSONBody defines parameters for PublishEvent.
type PublishEventJSONBody map[string]string

// RegisterEventTypesJSONBody defines parameters for RegisterEventTypes.
type RegisterEventTypesJSONBody = []EventType

// TriggerActionJSONRequestBody defines body for TriggerAction for application/json ContentType.
type TriggerActionJSONRequestBody TriggerActionJSONBody

// RegisterActionTypesJSONRequestBody defines body for RegisterActionTypes for application/json ContentType.
type RegisterActionTypesJSONRequestBody = RegisterActionTypesJSONBody

// PublishEventJSONRequestBody defines body for PublishEvent for application/json ContentType.
type PublishEventJSONRequestBody PublishEventJSONBody

// RegisterEventTypesJSONRequestBody defines body for RegisterEventTypes for application/json ContentType.
type RegisterEventTypesJSONRequestBody = RegisterEventTypesJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Subscribe to actions by source ID (WebSocket)
	// (GET /action/{source_id})
	SubscribeActionWS(ctx echo.Context, sourceId SourceID, params SubscribeActionWSParams) error
	// Trigger an action
	// (POST /action/{source_id}/{name})
	TriggerAction(ctx echo.Context, sourceId SourceID, name ActionName) error
	// List action types
	// (GET /action_type)
	GetActionTypes(ctx echo.Context) error
	// Register one or more action types
	// (POST /action_type)
	RegisterActionTypes(ctx echo.Context) error
	// Get action types by source ID
	// (GET /action_type/{source_id})
	GetActionTypesBySourceID(ctx echo.Context, sourceId SourceID) error
	// Get an action type by source ID and name
	// (GET /action_type/{source_id}/{name})
	GetActionType(ctx echo.Context, sourceId SourceID, name ActionName) error
	// Subscribe to events by source ID (WebSocket)
	// (GET /event/{source_id})
	SubscribeEventWS(ctx echo.Context, sourceId SourceID, params SubscribeEventWSParams) error
	// Publish an event
	// (POST /event/{source_id}/{name})
	PublishEvent(ctx echo.Context, sourceId SourceID, name EventName) error
	// List event types
	// (GET /event_type)
	GetEventTypes(ctx echo.Context) error
	// Register one or more event types
	// (POST /event_type)
	RegisterEventTypes(ctx echo.Context) error
	// Get event types by source ID
	// (GET /event_type/{source_id})
	GetEventTypesBySourceID(ctx echo.Context, sourceId SourceID) error
	// Get an event type by source ID and name
	// (GET /event_type/{source_id}/{name})
	GetEventType(ctx echo.Context, sourceId SourceID, name EventName) error
	// Subscribe to events and actions (SocketIO)
	// (GET /socket.io)
	SubscribeSIO(ctx echo.Context) error
	// Poll events and actions (SocketIO)
	// (POST /socket.io)
	PollSIO(ctx echo.Context) error
	// Subscribe to events and actions (SocketIO)
	// (GET /socket.io/)
	SubscribeSIO2(ctx echo.Context) error
	// Poll events and actions (SocketIO)
	// (POST /socket.io/)
	PollSIO2(ctx echo.Context) error

	// (GET /ysk)
	GetYskCard(ctx echo.Context) error

	// (DELETE /ysk/{id})
	DeleteYskCard(ctx echo.Context, id string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SubscribeActionWS converts echo context to params.
func (w *ServerInterfaceWrapper) SubscribeActionWS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source_id" -------------
	var sourceId SourceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "source_id", runtime.ParamLocationPath, ctx.Param("source_id"), &sourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_id: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SubscribeActionWSParams
	// ------------- Optional query parameter "names" -------------

	err = runtime.BindQueryParameter("form", true, false, "names", ctx.QueryParams(), &params.Names)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SubscribeActionWS(ctx, sourceId, params)
	return err
}

// TriggerAction converts echo context to params.
func (w *ServerInterfaceWrapper) TriggerAction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source_id" -------------
	var sourceId SourceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "source_id", runtime.ParamLocationPath, ctx.Param("source_id"), &sourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_id: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name ActionName

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TriggerAction(ctx, sourceId, name)
	return err
}

// GetActionTypes converts echo context to params.
func (w *ServerInterfaceWrapper) GetActionTypes(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetActionTypes(ctx)
	return err
}

// RegisterActionTypes converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterActionTypes(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterActionTypes(ctx)
	return err
}

// GetActionTypesBySourceID converts echo context to params.
func (w *ServerInterfaceWrapper) GetActionTypesBySourceID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source_id" -------------
	var sourceId SourceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "source_id", runtime.ParamLocationPath, ctx.Param("source_id"), &sourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_id: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetActionTypesBySourceID(ctx, sourceId)
	return err
}

// GetActionType converts echo context to params.
func (w *ServerInterfaceWrapper) GetActionType(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source_id" -------------
	var sourceId SourceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "source_id", runtime.ParamLocationPath, ctx.Param("source_id"), &sourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_id: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name ActionName

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetActionType(ctx, sourceId, name)
	return err
}

// SubscribeEventWS converts echo context to params.
func (w *ServerInterfaceWrapper) SubscribeEventWS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source_id" -------------
	var sourceId SourceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "source_id", runtime.ParamLocationPath, ctx.Param("source_id"), &sourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_id: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SubscribeEventWSParams
	// ------------- Optional query parameter "names" -------------

	err = runtime.BindQueryParameter("form", true, false, "names", ctx.QueryParams(), &params.Names)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SubscribeEventWS(ctx, sourceId, params)
	return err
}

// PublishEvent converts echo context to params.
func (w *ServerInterfaceWrapper) PublishEvent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source_id" -------------
	var sourceId SourceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "source_id", runtime.ParamLocationPath, ctx.Param("source_id"), &sourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_id: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name EventName

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PublishEvent(ctx, sourceId, name)
	return err
}

// GetEventTypes converts echo context to params.
func (w *ServerInterfaceWrapper) GetEventTypes(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetEventTypes(ctx)
	return err
}

// RegisterEventTypes converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterEventTypes(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RegisterEventTypes(ctx)
	return err
}

// GetEventTypesBySourceID converts echo context to params.
func (w *ServerInterfaceWrapper) GetEventTypesBySourceID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source_id" -------------
	var sourceId SourceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "source_id", runtime.ParamLocationPath, ctx.Param("source_id"), &sourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_id: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetEventTypesBySourceID(ctx, sourceId)
	return err
}

// GetEventType converts echo context to params.
func (w *ServerInterfaceWrapper) GetEventType(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source_id" -------------
	var sourceId SourceID

	err = runtime.BindStyledParameterWithLocation("simple", false, "source_id", runtime.ParamLocationPath, ctx.Param("source_id"), &sourceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_id: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name EventName

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetEventType(ctx, sourceId, name)
	return err
}

// SubscribeSIO converts echo context to params.
func (w *ServerInterfaceWrapper) SubscribeSIO(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SubscribeSIO(ctx)
	return err
}

// PollSIO converts echo context to params.
func (w *ServerInterfaceWrapper) PollSIO(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PollSIO(ctx)
	return err
}

// SubscribeSIO2 converts echo context to params.
func (w *ServerInterfaceWrapper) SubscribeSIO2(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SubscribeSIO2(ctx)
	return err
}

// PollSIO2 converts echo context to params.
func (w *ServerInterfaceWrapper) PollSIO2(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PollSIO2(ctx)
	return err
}

// GetYskCard converts echo context to params.
func (w *ServerInterfaceWrapper) GetYskCard(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetYskCard(ctx)
	return err
}

// DeleteYskCard converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteYskCard(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteYskCard(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/action/:source_id", wrapper.SubscribeActionWS)
	router.POST(baseURL+"/action/:source_id/:name", wrapper.TriggerAction)
	router.GET(baseURL+"/action_type", wrapper.GetActionTypes)
	router.POST(baseURL+"/action_type", wrapper.RegisterActionTypes)
	router.GET(baseURL+"/action_type/:source_id", wrapper.GetActionTypesBySourceID)
	router.GET(baseURL+"/action_type/:source_id/:name", wrapper.GetActionType)
	router.GET(baseURL+"/event/:source_id", wrapper.SubscribeEventWS)
	router.POST(baseURL+"/event/:source_id/:name", wrapper.PublishEvent)
	router.GET(baseURL+"/event_type", wrapper.GetEventTypes)
	router.POST(baseURL+"/event_type", wrapper.RegisterEventTypes)
	router.GET(baseURL+"/event_type/:source_id", wrapper.GetEventTypesBySourceID)
	router.GET(baseURL+"/event_type/:source_id/:name", wrapper.GetEventType)
	router.GET(baseURL+"/socket.io", wrapper.SubscribeSIO)
	router.POST(baseURL+"/socket.io", wrapper.PollSIO)
	router.GET(baseURL+"/socket.io/", wrapper.SubscribeSIO2)
	router.POST(baseURL+"/socket.io/", wrapper.PollSIO2)
	router.GET(baseURL+"/ysk", wrapper.GetYskCard)
	router.DELETE(baseURL+"/ysk/:id", wrapper.DeleteYskCard)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
